<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>损失函数与正则化</title>
    <link href="/2023/08/31/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B8%8E%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <url>/2023/08/31/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B8%8E%E6%AD%A3%E5%88%99%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><p><strong>损失函数</strong>用来评价模型的<strong>预测值</strong>和<strong>真实值</strong>不一样的程度，损失函数越好，通常模型的性能越好。不同的模型用的损失函数一般也不一样。</p><p><strong>损失函数</strong>分为<strong>经验风险损失函数</strong>和<strong>结构风险损失函数</strong>。经验风险损失函数指预测结果和实际结果的差别，结构风险损失函数是指经验风险损失函数加上正则项。</p><p><strong>基本概念：</strong></p><p>损失函数：计算的是一个样本的误差</p><p>代价函数：是整个训练集上所有样本误差的平均</p><p>目标函数：代价函数 + 正则化项</p><p><strong>损失函数（loss function）</strong>是用来估量你模型的预测值f(x)与真实值Y的不一致程度，它是一个非负实值函数,通常使用L(Y, f(x))来表示，损失函数越小，模型的鲁棒性就越好。</p><p>损失函数是<strong>经验风险函数</strong>的核心部分，也是结构风险函数重要组成部分。</p><p>模型的<strong>结构风险函数</strong>包括了经验风险项和正则项，即最优化经验风险和结构风险，而这个函数就被称为<strong>目标函数</strong></p><h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><p><a href="https://charlesliuyx.github.io/2017/10/03/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E5%8C%96/">【直观详解】什么是正则化 | Go Further | Stay Hungry, Stay Foolish (charlesliuyx.github.io)</a></p><p><a href="https://www.bilibili.com/video/BV1aE411o7qd/?p=11&spm_id_from=pageDriver&vd_source=cf891a3e71b6dda092ce868f3c80895c">(系列三) 线性回归3-正则化-岭回归-频率角度_哔哩哔哩_bilibili</a>（为什么正则化可以防止过拟合视频）</p><p><a href="https://zhuanlan.zhihu.com/p/581267829">为什么正则化可以防止过拟合？ - 知乎 (zhihu.com)</a></p><h2 id="为什么要有正则化"><a href="#为什么要有正则化" class="headerlink" title="为什么要有正则化"></a>为什么要有正则化</h2><p>从使用正则化的目的角度：<strong>正则化是为了防止过拟合</strong>。</p><h2 id="正则化如何实现目的"><a href="#正则化如何实现目的" class="headerlink" title="正则化如何实现目的"></a>正则化如何实现目的</h2><ul><li><p><strong>通俗地理解怎么做到这一点：</strong>向你的模型加入某些规则，加入先验，缩小解空间，减小求出错误解的可能性。你要把你的知识数学化告诉这个模型，对代价函数来说，就是加入对模型“长相”的惩罚</p></li><li><p><strong>权衡的角度理解怎么做到这一点：</strong></p><p>很多人都在讲偏差-方差的权衡（bias-variance tradeoff），实际上在这里还有一个权衡，即<strong>样本内的误差与模型（或者参数）的误差之间的权衡</strong>。模型越「大」，则样本内的误差越小，但是参数的误差可能会很大：比如在第一张图中，如果使用了太高阶的多项式，样本点的一个小小的扰动都会使得估计出的模型（参数）有非常大的变化；而<strong>模型越「小」，样本内的均方误差会大一些，但是参数的均方误差可以变的比较小。</strong></p><p>而<strong>正则化，就是通过收缩的办法，限制模型变的越来越「大」，牺牲样本内误差，降低模型（参数）的误差，从而提高样本外的预测效果</strong>，防止过拟合。</p></li></ul><h2 id="正则化的公式"><a href="#正则化的公式" class="headerlink" title="正则化的公式"></a>正则化的公式</h2><ul><li><p>p正则化其实就是在原来的损失函数后面加上一个带正则化系数的p范数</p><ul><li><p>L1正则化</p><p>J(w)&#x3D;12m∑i&#x3D;1m(hw(x(i))−y(i))2+λ∣∣w∣∣1J(w) &#x3D; \frac{1}{2m}\sum_{i&#x3D;1}^{m}(h_w(x^{(i)})-y^{(i)})^2 + \lambda||w||_1J(w)&#x3D;2m1∑i&#x3D;1m(hw(x(i))−y(i))2+λ∣∣w∣∣1</p></li><li><p>L2正则化</p><p>J(w)&#x3D;12m∑i&#x3D;1m(hw(x(i))−y(i))2+λ2∣∣w∣∣22J(w) &#x3D; \frac{1}{2m}\sum_{i&#x3D;1}^{m}(h_w(x^{(i)})-y^{(i)})^2 + \frac{\lambda}{2}||w||_2^2J(w)&#x3D;2m1∑i&#x3D;1m(hw(x(i))−y(i))2+2λ∣∣w∣∣22</p></li><li><p>正则化系数λ\lambdaλ</p><p>在正则化中，正则化系数 λ\lambdaλ 控制着正则化的强度，<strong>较大的 *<em>**λ\lambdaλ**</em>* 会导致模型更加倾向于简单的解决方案，而较小的 *<em>**λ\lambdaλ**</em>* 则会让模型更倾向于拟合训练数据。</strong></p></li></ul></li></ul><h2 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h2><ul><li>所以最后加上的正则化项其实衡量的就是模型输出（xix_ixi）之间的方差（L2正则化为例），所以模型越大，方差自然也就越大，也就是惩罚越多。这也是前面说的模型大模型小的含义。</li></ul><h2 id="【补充理解】范数"><a href="#【补充理解】范数" class="headerlink" title="【补充理解】范数"></a>【补充理解】范数</h2><ul><li>p范数公式</li></ul><p><img src="https://secure2.wostatic.cn/static/gunm6eRdXMA1xZXtVnKjVm/image.png?auth_key=1693486530-3tFtq8QbysyMxwsKQgbBkh-0-2c0365af4f6d7edb6eb86caf8a48d420" alt="img"></p><p><strong>0范数</strong>，向量中非零元素的个数。</p><p><strong>1范数</strong>，为绝对值之和。</p><p><strong>2范数</strong>，就是通常意义上的模。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>L1正则化可以得到稀疏解</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程笔记</title>
    <link href="/2022/12/02/Linux%E8%BF%9B%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/12/02/Linux%E8%BF%9B%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="进程初探"><a href="#进程初探" class="headerlink" title="进程初探"></a>进程初探</h1><ul><li>系统初始进程启动步骤<ol><li>系统启动时，内核<strong>先把一些它自己的活动初始化为进程</strong></li><li><strong>运行一个叫做 init 的程<br> 序</strong>。init，依次地，<strong>再运行一系列的称为 init 脚本的 shell 脚本</strong>（位于&#x2F;etc），它们可以启动所有<br> 的系统服务。其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，<br> 没有任何用户接口 (User Interface)。</li></ol></li><li>在进程方案中，<strong>一个程序可以发动另一个程序被表述为一个父进程可以产生一个子进程。</strong></li><li>内核维护每个进程的信息，每个进程有自己的PID（Process ID），init进程的PID总是1</li></ul><p><img src="https://secure2.wostatic.cn/static/axut6zcsFknPjzhFQfh1J4/image.png?auth_key=1669917071-e6bFPxcKqcDBxUw5dsNxgz-0-142a1566a3f3f70f4a5fa9ec273542af" alt="img"></p><h1 id="进程相关的命令"><a href="#进程相关的命令" class="headerlink" title="进程相关的命令"></a>进程相关的命令</h1><ul><li><p>ps</p><ul><li><p>option</p><ul><li><p>不带option</p><p><img src="https://secure2.wostatic.cn/static/45nWuY8FqeaX9F3qmwcoaT/image.png?auth_key=1669917071-f96h1e983cYHta2UbXYmjW-0-494a8be04bc78773be3271be28566403" alt="img"></p><ul><li>默认情况下，ps 不会显示很多进程信息，只是列出<strong>与当前终端会话相关的进程</strong>。</li><li>字段释义<ul><li>TTY 是指进程的控制终端。</li><li>TIME 字段表示进程所消耗的 CPU 时间数量。</li></ul></li></ul></li><li><p>带 -x（要是不行就 <code>ps x </code> 不要<code>ps -x</code>）</p><p><img src="https://secure2.wostatic.cn/static/ecmtkLS3S4N8khDzgQ1Ssb/image.png?auth_key=1669917071-trZjLtodXdKiPHrDhVkrbY-0-e6c1dc27050bf459c2a1cedca7496cf5" alt="img"></p><ul><li><p>可以看到我们所拥有的<strong>每个进程的信息</strong></p></li><li><p>字段释义</p><ul><li><p>TTY 一栏中出现的 “?” ，表示没有控制终端</p></li><li><p>STAT（State） 揭示了进程当前状态</p><p><img src="https://secure2.wostatic.cn/static/p9JREfb6wRkbzvZMc29PN/image.png?auth_key=1669917071-wGUPUMS2tnJ11f1G2oj1cx-0-40607285e61cbb951be0a24041a7f76c" alt="img"></p></li></ul></li></ul></li><li><p>带 -aux</p><p><img src="https://secure2.wostatic.cn/static/ktqArghyiZm2cBjxpHiQBh/image.png?auth_key=1669917071-b5ycDV8HdgodvCCF65TusD-0-36ee81ce181d7c868d92f8d3abd6e731" alt="img"></p><ul><li><p>能够显示属于<strong>每个用户的进程信息</strong></p></li><li><p>字段含义</p><p><img src="https://secure2.wostatic.cn/static/rHbXwTKXqZEqkDZVGejeUS/image.png?auth_key=1669917071-7ZUcZ2cGgghBRyPUK99iGp-0-6485204788cd0c4d9969376e1820312c" alt="img"></p></li></ul></li></ul></li></ul></li><li><p>top</p><ul><li><p>ps只是提供 ps 命令执行时刻的机器状态快照。top可以使我们看到更多动态的信息。</p></li><li><p>top命令最上面是系统概要，下面是进程列表，以 CPU 的使用率排序</p><p><img src="https://secure2.wostatic.cn/static/jrzsQ1kird3nfsL2D9x4Hg/image.png?auth_key=1669917071-8Mgqr9HRXaKSsqRgAQgaE8-0-f24da331264e3b2947fc224ce56563e7" alt="img"></p><ul><li><p>系统概要详解</p><p><img src="https://secure2.wostatic.cn/static/oNj9TVqCrw2Do5WkWTRpuZ/image.png?auth_key=1669917071-cHkg4z7MxiZh9TEqhSrwKy-0-e4296b49cddaeeeb1e209d74dce4d8e5" alt="img"></p><p><img src="https://secure2.wostatic.cn/static/4bp4dTHAW69abdba9ZmPcN/image.png?auth_key=1669917071-2DASoKdkEhj4bVvMiC4ddC-0-f240920e6724c4f02dc6f2982c997977" alt="img"></p></li></ul></li><li><p>在top界面输入h可以显示帮助，输入q可以退出top</p><p><img src="https://secure2.wostatic.cn/static/bRPBFeKuRY29FCXPCcf6gQ/image.png?auth_key=1669917071-dKqqKisjqBkDNr7opRZrim-0-2b079fa1900a0f8b18b56a9160a71cd6" alt="img"></p></li></ul></li></ul><h1 id="进程的前后台执行切换"><a href="#进程的前后台执行切换" class="headerlink" title="进程的前后台执行切换"></a>进程的前后台执行切换</h1><ul><li><p>启动时后台执行</p><ul><li><p>启动一个程序并让它立即在后台运行，在程序命令之后，加上 “&amp;” 字符</p><p><img src="https://secure2.wostatic.cn/static/6MLb2L8LRi9DLyrDCWbKUi/image.png?auth_key=1669917071-bm4zQYxJ7vwFn64RU1tFF4-0-5feda753417ece0e5b14a066de0a946f" alt="img"></p><ul><li>打印的东西叫做任务控制 (job control)。通过这条信息，shell 告诉我们，已经启动了<strong>任务号 (job number) 为 1（“［1］”），PID 为 28236 的程序</strong></li></ul></li><li><p>jobs可以查看终端启动了的任务</p><p><img src="https://secure2.wostatic.cn/static/hNaTViSHbihiTc9cggeiLT/image.png?auth_key=1669917071-cCzV9WE259LfJyXBYf8nus-0-75fd59bffd04f9eb66fe9c017788335f" alt="img"></p><ul><li>显示我们有一个任务，编号为“1”，它正在运行，并且这个任务的命令是 <code>xlogo ＆</code></li></ul></li></ul></li><li><p>切换后台程序到前台</p><ul><li><p>fg 命令之后，跟随着一个百分号和任务序号（叫做 jobspec, 如此处的%1）</p><p><img src="https://secure2.wostatic.cn/static/vSet4CFC9JqLY73vyKyzov/image.png?auth_key=1669917071-f7YSSARvaboKVEhxuzL1VD-0-7856168f8a4be3ea5e61d10123ab603e" alt="img"></p></li></ul></li><li><p>暂停进程（为了使得一个正在前台运行的程序移动到后台）</p><ul><li><p>进程必须先暂停才能移动到后台</p></li><li><p>执行 <code>Ctrl-z</code></p><p><img src="https://secure2.wostatic.cn/static/pLycJqxzSziWUKyoYEvRnt/image.png?auth_key=1669917071-ooJV4xGeJqcuaxfwWo6kgR-0-77562ad131171d776b7b6cc2f84c7b7d" alt="img"></p></li><li><p>暂停后</p><ol><li><p>可以通过bg命令移动到后台</p><p><img src="https://secure2.wostatic.cn/static/cavrh8QegUHiQkKKNQfueu/image.png?auth_key=1669917071-ahkkMLkd234GPosaSdtTRW-0-62b0484eb3e6feec380675a0aa97ecd5" alt="img"></p></li><li><p>可以通过fg命令恢复前台运行</p></li></ol></li></ul></li><li><p>终止进程</p><ul><li><p>kill 命令不是真的“杀死”程序，而是<strong>给程序发送信号</strong>。（信号是<strong>操作系统与程序之间进行通信</strong>时所采用的几种方式中的一种）</p></li><li><p>kill [-signal] PID</p><ul><li><p>-signal</p><ul><li><p>如果在命令行中没有指定信号，那么默认情况下，发送 TERM（Terminate，终止）信号</p></li><li><p>完整 -signal 含义</p><p><img src="https://secure2.wostatic.cn/static/67PaekvTYxY1eWTKDZYqy2/image.png?auth_key=1669917072-9SN6xpPtJKFL2fLZaQ7obm-0-5a6058f650b86be7a4e102ae4a4131b4" alt="img"></p><p><img src="https://secure2.wostatic.cn/static/6s2vcV8iBtE36gBMbhMe3y/image.png?auth_key=1669917072-txbBvTwEFrLbLsPgvsoXmg-0-efa4c2efd6f82ae647c3f31bec8efac6" alt="img"></p></li></ul></li><li><p>信号（signal）既可以用号码，也可以用名字来指定，可以在名字前面加上字母“SIG”的名字。</p><ul><li>意思就是可以用 -15 ，也可以用 -TERM，也可以用 -SIGTERM</li></ul></li><li><p>用 jobspecs （一个百分号和任务序号，比如%1）来代替 PID</p></li></ul><p><img src="https://secure2.wostatic.cn/static/hnd1gUkf2p4TVGuWq1P4u6/image.png?auth_key=1669917072-2wyFmRugYDDxFsWgdZrakt-0-874c7b87124753c64a1ff54f6836f97a" alt="img"></p><p><img src="https://secure2.wostatic.cn/static/d4jkWr6f3wBgnvCzWWCMdG/image.png?auth_key=1669917072-mNnjiUpC7zGJ3PRHzD8B81-0-412f624a261c11c6b6b4d03105a7c166" alt="img"></p></li></ul></li><li><p>如果要<strong>在关闭连接终端后还能执行</strong>，就必须在命令前面再加上一个<code>nohup</code></p><ul><li><code>nohup xlogo &amp;</code></li></ul></li><li><p>实际应用</p><ul><li><p>一般后台运行会<strong>配合把输出重定向到日志文件</strong></p></li><li><p>tail也是很有用的技巧，不然放后台运行了就不知道目前命令的执行情况了</p><ul><li>加上 -f之后可以实时地浏览文件，tail 命令会继续监测这个文件，当新的内容添加到文件后，它们会立即出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。</li></ul></li><li><p>例子</p><p><img src="https://secure2.wostatic.cn/static/tnK9ss5m88sLYyypf8kwV9/image.png?auth_key=1669917072-vNrXMR7o666E5U9ZFqHvjS-0-5c7b536c8b6dd8eaff8a93391a75b167" alt="img"></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
